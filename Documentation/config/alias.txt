alias.*::
	Command aliases for the linkgit:git[1] command wrapper - e.g.
	after defining `alias.last = cat-file commit HEAD`, the invocation
	`git last` is equivalent to `git cat-file commit HEAD`. To avoid
	confusion and troubles with script usage, aliases that
	hide existing Git commands are ignored. Arguments are split by
	spaces, the usual shell quoting and escaping are supported.
	A quote pair or a backslash can be used to quote them.
+
Note that the first word of an alias does not necessarily have to be a
command. It can be a command-line option that will be passed into the
invocation of `git`. In particular, this is useful when used with `-c`
to pass in one-time configurations or `-p` to force pagination. For example,
`loud-rebase = -c commit.verbose=true rebase` can be defined such that
running `git loud-rebase` would be equivalent to
`git -c commit.verbose=true rebase`. Also, `ps = -p status` would be a
helpful alias since `git ps` would paginate the output of `git status`
where the original command does not.
+
If the alias expansion is prefixed with an exclamation point,
it will be treated as a shell command.  For example, defining
`alias.new = !gitk --all --not ORIG_HEAD`, the invocation
`git new` is equivalent to running the shell command
`gitk --all --not ORIG_HEAD`.  Note:
+
* Shell commands will be executed from the top-level directory of a
  repository, which may not necessarily be the current directory.
* `GIT_PREFIX` is set as returned by running `git rev-parse --show-prefix`
  from the original current directory. See linkgit:git-rev-parse[1].
* If the shell alias is the full path to a binary, it will be executed
  directly with any arguments as positional arguments.
* If the alias contains any white-space or reserved characters, it
  will be considered an inline script and run as an argument to `sh
  -c`.
* When running as a script, if arguments are provided to the alias
  call, Git makes them available to the process by appending "$@" to
  the alias shell command.  This is not appended if arguments are not
  provided.
** For "simple" commands, such as calling a single binary
  (e.g. `alias.myapp = !myapp --myflag1`) this will result in any
  arguments becoming additional regular positional arguments to the
  called binary, appended after any arguments specified in the aliased
  command.
** Care should be taken if your alias script has multiple commands
   (e.g. in a pipeline), references argument variables, or is
   otherwise not expecting the presence of the appended `"$@"`.  For
   example: `alias.echo = "!echo $1"` when run as `git echo arg` will
   actually execute `sh -c "echo $1 $@" "echo $1" "arg"` resulting in
   output `arg arg`.  When writing such aliases, you should ensure
   that the appended "$@" when arguments are present does not cause
   syntax errors or unintended side-effects.
** A convenient way to deal with this is to write your script
   operations in an inline function that is then called with any
   arguments from the command-line.  For example `alias.cmd = "!c() {
   cmd $1 | cmd $2 ; }; c" will allow you to work with separate
   arguments.
** Setting `GIT_TRACE=1` can help debug the command being run.
